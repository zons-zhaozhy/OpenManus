"""
数据库设计师智能体 - 专业级数据架构设计与优化
"""

import json
import re
from datetime import datetime
from typing import Dict, List, Optional, Tuple

from app.agent.base import BaseAgent
from app.logger import logger
from app.schema import Message


class DatabaseDesignerAgent(BaseAgent):
    """首席数据架构师 - 基于现代数据建模理论设计高性能数据架构"""

    def __init__(
        self,
        name: str = "首席数据架构师",
        description: str = "基于现代数据建模理论和性能优化策略设计企业级数据架构",
        **kwargs,
    ):
        super().__init__(name=name, description=description, **kwargs)

        # 现代数据库技术知识库
        self.database_technologies = {
            "关系型数据库": {
                "PostgreSQL": {
                    "特性": ["ACID事务", "JSON支持", "全文搜索", "地理空间数据"],
                    "性能": {"读性能": 9, "写性能": 8, "扩展性": 8, "一致性": 10},
                    "适用场景": ["复杂查询", "事务一致性", "数据完整性", "企业应用"],
                },
                "MySQL": {
                    "特性": ["高性能", "复制机制", "分区表", "存储引擎"],
                    "性能": {"读性能": 9, "写性能": 9, "扩展性": 7, "一致性": 9},
                    "适用场景": ["Web应用", "读写分离", "高并发", "OLTP"],
                },
                "Oracle": {
                    "特性": ["企业级功能", "高可用", "数据压缩", "分析函数"],
                    "性能": {"读性能": 8, "写性能": 8, "扩展性": 9, "一致性": 10},
                    "适用场景": ["大型企业", "复杂业务", "数据仓库", "高可用"],
                },
            },
            "NoSQL数据库": {
                "MongoDB": {
                    "特性": ["文档存储", "动态schema", "水平扩展", "地理空间"],
                    "性能": {"读性能": 8, "写性能": 9, "扩展性": 9, "一致性": 7},
                    "适用场景": ["内容管理", "实时分析", "IoT数据", "快速开发"],
                },
                "Redis": {
                    "特性": ["内存存储", "数据结构", "发布订阅", "Lua脚本"],
                    "性能": {"读性能": 10, "写性能": 10, "扩展性": 8, "一致性": 8},
                    "适用场景": ["缓存", "会话存储", "消息队列", "实时计数"],
                },
                "Elasticsearch": {
                    "特性": ["全文搜索", "分布式", "实时分析", "日志分析"],
                    "性能": {"读性能": 9, "写性能": 8, "扩展性": 9, "一致性": 7},
                    "适用场景": ["搜索引擎", "日志分析", "实时监控", "数据探索"],
                },
            },
        }

        # 数据建模最佳实践
        self.modeling_practices = {
            "领域驱动设计": {
                "聚合设计": "根据业务不变性设计聚合边界",
                "实体识别": "区分实体、值对象、服务",
                "上下文映射": "明确限界上下文和数据边界",
                "事件建模": "基于领域事件设计数据流",
            },
            "数据规范化": {
                "第一范式": "消除重复列，确保原子性",
                "第二范式": "消除部分函数依赖",
                "第三范式": "消除传递函数依赖",
                "反规范化": "为性能考虑的冗余设计",
            },
            "性能建模": {
                "读写分离": "CQRS模式，读写模型分离",
                "事件溯源": "基于事件的数据存储模式",
                "分片策略": "水平分割的数据分布",
                "缓存模式": "多级缓存和失效策略",
            },
        }

        # 性能优化策略库
        self.performance_optimization = {
            "索引优化": {
                "B+树索引": "平衡树索引，适用范围查询",
                "哈希索引": "快速等值查询，内存数据库",
                "位图索引": "低基数列的数据仓库应用",
                "复合索引": "多列组合索引，覆盖查询",
                "部分索引": "条件索引，减少索引大小",
                "表达式索引": "函数索引，复杂查询优化",
            },
            "查询优化": {
                "执行计划": "分析查询执行路径和成本",
                "统计信息": "维护准确的表统计信息",
                "查询重写": "等价查询变换优化",
                "子查询优化": "相关子查询转连接",
                "分区裁剪": "分区表的查询优化",
                "并行查询": "利用多核并行处理",
            },
            "存储优化": {
                "数据压缩": "行压缩和列压缩技术",
                "分区表": "水平分区和垂直分区",
                "表空间": "物理存储空间管理",
                "页面填充": "控制页面填充因子",
                "数据类型": "选择最优数据类型",
                "归档策略": "历史数据归档管理",
            },
        }

        # 数据安全框架
        self.security_framework = {
            "访问控制": {
                "角色权限": "RBAC基于角色的访问控制",
                "行级安全": "RLS行级别数据安全",
                "列级加密": "敏感列的透明加密",
                "数据脱敏": "生产数据的脱敏处理",
            },
            "审计监控": {
                "操作审计": "DML/DDL操作记录",
                "登录监控": "用户登录和权限使用",
                "数据变更": "敏感数据变更跟踪",
                "性能监控": "查询性能和资源使用",
            },
            "备份恢复": {
                "备份策略": "全量、增量、日志备份",
                "恢复测试": "定期恢复演练",
                "异地备份": "跨地域数据保护",
                "快照技术": "存储级快照备份",
            },
        }

        # 专业数据架构师提示词
        self.system_prompt = """你是一名拥有15年经验的首席数据架构师，专精于现代数据库设计和数据架构，擅长：

## 核心专业能力
1. **数据建模精通**：精通ER建模、维度建模、领域驱动设计的数据建模方法
2. **性能工程**：基于查询模式和数据分布设计高性能数据架构
3. **数据安全**：设计完整的数据安全体系，保障数据隐私和合规
4. **扩展性设计**：设计支持海量数据和高并发的可扩展数据架构
5. **多数据库精通**：精通关系型、NoSQL、时序、图数据库的特性和应用

## 设计方法论
### 1. 数据驱动建模
- **业务理解**：深入理解业务域和数据流，识别核心实体和关系
- **查询模式分析**：基于实际查询负载设计物理模型
- **数据生命周期**：考虑数据的产生、使用、归档、销毁全流程
- **一致性要求**：根据CAP定理权衡一致性、可用性、分区容错性

### 2. 现代数据架构
- **多模数据库**：为不同数据类型选择最适合的存储引擎
- **CQRS模式**：读写分离，优化查询和更新性能
- **事件驱动**：基于事件溯源的数据架构设计
- **数据网格**：分布式数据架构，领域数据所有权

### 3. 性能优化体系
- **索引策略**：基于查询模式设计最优索引组合
- **分区分片**：数据分布策略，实现水平扩展
- **缓存层次**：多级缓存，减少数据库负载
- **查询优化**：SQL优化、执行计划分析、统计信息维护

### 4. 数据安全与治理
- **数据分级**：敏感数据识别和分级保护
- **加密策略**：传输加密、存储加密、密钥管理
- **审计合规**：操作审计、数据血缘、合规报告
- **备份恢复**：RTO/RPO目标下的备份恢复策略

## 技术前瞻性
### 云原生数据库
- **数据库即服务**：云托管数据库的选择和配置
- **Serverless数据库**：按需扩展的数据库架构
- **多云架构**：跨云数据同步和灾备策略

### 大数据集成
- **实时数据管道**：Kafka、Flink等流处理集成
- **数据湖架构**：结构化、半结构化数据统一存储
- **OLAP分析**：数据仓库、数据集市设计

### AI/ML数据支持
- **特征存储**：机器学习特征工程数据库
- **向量数据库**：支持AI应用的向量检索
- **图数据库**：复杂关系分析和推荐系统

## 输出标准
1. **业务对齐**：数据模型完全映射业务概念和关系
2. **性能优化**：基于实际负载的性能优化设计
3. **安全合规**：满足数据安全和行业合规要求
4. **可运维性**：考虑监控、备份、升级的运维友好设计
5. **可扩展性**：支持业务增长和数据量扩展的架构设计

## 设计交付物
1. **概念数据模型**：ER图、实体关系、业务规则
2. **逻辑数据模型**：表结构、字段定义、约束关系
3. **物理数据模型**：索引设计、分区策略、存储优化
4. **性能设计**：查询优化、缓存策略、扩展方案
5. **安全设计**：访问控制、加密策略、审计体系
6. **运维设计**：监控指标、备份策略、升级方案

专业、严谨、前瞻是你的核心特质。"""

    async def design_database_schema(
        self,
        requirements_doc: str,
        architecture_doc: str,
        project_constraints: Optional[Dict] = None,
    ) -> str:
        """专业数据库架构设计"""
        logger.info("🗄️ 开始专业数据库架构设计")

        # 解析项目约束
        constraints = project_constraints or {}
        data_volume = constraints.get("data_volume", "中等数据量")
        performance_requirements = constraints.get(
            "performance_requirements", "标准性能"
        )
        compliance_requirements = constraints.get(
            "compliance_requirements", "一般合规要求"
        )

        design_prompt = f"""请基于以下信息进行企业级数据库架构设计：

## 项目输入
### 需求规格说明书
{requirements_doc}

### 系统架构设计
{architecture_doc}

### 数据约束条件
- **数据量级**: {data_volume}
- **性能要求**: {performance_requirements}
- **合规要求**: {compliance_requirements}
- **设计时间**: {datetime.now().strftime('%Y年%m月')} (请考虑最新数据库技术)

请运用你的专业知识和数据建模最佳实践，输出一份详实的数据库设计文档。

# 企业级数据库架构设计文档

## 1. 数据架构执行摘要
- **数据库选型策略**: [主数据库+辅助数据库组合]
- **数据建模方法**: [ER建模/DDD/维度建模等]
- **核心架构决策**: [3-5个关键数据架构决策]
- **预估数据复杂度**: [低/中/高] 及复杂度来源
- **性能预期目标**: [QPS、存储量、响应时间等具体指标]

## 2. 业务数据分析

### 2.1 领域模型分析
**核心业务域识别**:
- **[业务域1]**: [核心实体、关键属性、业务规则]
- **[业务域2]**: [核心实体、关键属性、业务规则]
- **[业务域3]**: [核心实体、关键属性、业务规则]

**领域边界定义**:
- **上下文映射**: [不同上下文的数据边界]
- **聚合设计**: [数据一致性边界]
- **实体关系**: [核心实体间的关联关系]

### 2.2 数据特征分析
**数据量分析**:
| 数据类型 | 预估记录数 | 增长率 | 存储需求 | 查询频率 |
|----------|------------|--------|----------|----------|
| [实体A数据] | X万/年 | X%/月 | XGB | 高频查询 |
| [实体B数据] | X万/年 | X%/月 | XGB | 中频查询 |

**查询模式分析**:
- **OLTP查询**: [事务处理类查询特征]
- **OLAP查询**: [分析类查询特征]
- **实时查询**: [实时性要求和查询模式]
- **批处理**: [批量数据处理需求]

## 3. 数据库选型与架构

### 3.1 数据库技术选型
**主数据库选择**: [具体数据库产品]
- **选型理由**: [基于数据特征的选择依据]
- **技术优势**: [对本项目的具体优势]
- **性能特征**: [读写性能、扩展性、一致性评分]
- **适用场景**: [最匹配的应用场景]

**辅助数据库**: [缓存、搜索、分析等专用数据库]
- **Redis缓存**: [缓存策略和数据结构选择]
- **Elasticsearch**: [搜索和日志分析需求]
- **时序数据库**: [如有监控、IoT数据需求]

### 3.2 数据架构模式
**架构模式选择**: [单库/主从/分片/多数据库]
- **模式特征**: [架构模式的具体特点]
- **适用理由**: [基于项目特征的选择]
- **扩展性**: [支持的扩展能力]
- **一致性**: [数据一致性保障]

**数据流架构**:
```
[数据流向图]
应用层 ──┬── 主数据库(写) ──┐
         │                   ├── 数据同步
         ├── 从数据库(读) ──┘
         │
         ├── Redis缓存 ────── 热点数据
         │
         └── ES搜索 ────────── 全文检索
```

## 4. 概念数据模型

### 4.1 实体关系设计
**核心实体定义**:
```
[ER图 - ASCII格式]
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│    用户     │    │    订单     │    │    商品     │
│─────────────│    │─────────────│    │─────────────│
│ +用户ID(PK) │    │ +订单ID(PK) │    │ +商品ID(PK) │
│  用户名     │    │  用户ID(FK) │    │  商品名称   │
│  邮箱       │────│  创建时间   │    │  价格       │
│  创建时间   │ 1:N│  总金额     │    │  库存       │
└─────────────┘    └─────┬───────┘    └──────┬──────┘
                         │ M:N                │ 1:N
                         │                    │
                   ┌─────┴───────┐           │
                   │   订单项    │───────────┘
                   │─────────────│
                   │ +项目ID(PK) │
                   │  订单ID(FK) │
                   │  商品ID(FK) │
                   │  数量       │
                   │  单价       │
                   └─────────────┘
```

**关系约束定义**:
- **一对一关系**: [具体关系和约束]
- **一对多关系**: [具体关系和约束]
- **多对多关系**: [通过中间表实现]
- **自引用关系**: [树形结构等自引用]

### 4.2 业务规则建模
**数据完整性规则**:
- **实体完整性**: [主键约束、非空约束]
- **参照完整性**: [外键约束、级联操作]
- **域完整性**: [数据类型、取值范围约束]
- **用户定义完整性**: [业务规则约束]

## 5. 逻辑数据模型

### 5.1 核心表结构设计
#### 用户表 (users)
```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '用户ID',
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
    email VARCHAR(100) NOT NULL UNIQUE COMMENT '邮箱地址',
    password_hash VARCHAR(255) NOT NULL COMMENT '密码哈希',
    phone VARCHAR(20) COMMENT '手机号',
    status TINYINT DEFAULT 1 COMMENT '状态:1-正常,0-禁用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',

    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_phone (phone),
    INDEX idx_status_created (status, created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户基础信息表';
```

#### [其他核心表按同样详细格式定义]

### 5.2 数据字典
| 表名 | 中文名 | 记录数预估 | 主要查询 | 更新频率 | 重要级别 |
|------|--------|------------|----------|----------|----------|
| users | 用户表 | 100万 | 登录查询、用户信息 | 中频 | 高 |
| orders | 订单表 | 1000万 | 订单查询、统计 | 高频 | 高 |
| products | 商品表 | 10万 | 商品检索、详情 | 中频 | 中 |

### 5.3 约束和触发器
**约束定义**:
- **检查约束**: [数据有效性检查]
- **唯一约束**: [业务唯一性保证]
- **外键约束**: [参照完整性保证]

**触发器设计**:
- **审计触发器**: [数据变更记录]
- **业务触发器**: [复杂业务规则]
- **同步触发器**: [数据同步处理]

## 6. 物理数据模型

### 6.1 索引策略设计
**主键索引策略**:
- **聚簇索引**: [主键选择和设计原则]
- **分布式主键**: [雪花算法、UUID等]
- **索引覆盖**: [覆盖索引设计]

**辅助索引设计**:
| 表名 | 索引名 | 索引列 | 索引类型 | 选择性 | 维护成本 |
|------|--------|--------|----------|--------|----------|
| users | idx_email | email | B+树 | 高 | 低 |
| orders | idx_user_time | user_id,created_at | 复合 | 中 | 中 |
| products | idx_category_price | category_id,price | 复合 | 中 | 低 |

**索引优化策略**:
- **复合索引顺序**: [基于查询模式的列顺序]
- **部分索引**: [条件索引减少索引大小]
- **函数索引**: [表达式索引支持复杂查询]

### 6.2 分区分片策略
**水平分区策略**:
- **分区键选择**: [基于查询模式的分区键]
- **分区方案**: [范围分区/哈希分区/列表分区]
- **分区数量**: [基于数据量和性能的分区数]

**分库分表策略**:
- **分片键设计**: [数据分布和查询模式平衡]
- **路由策略**: [数据路由和跨片查询]
- **数据迁移**: [分片扩容和数据重平衡]

### 6.3 存储优化
**数据类型优化**:
- **整数类型**: [根据取值范围选择最小类型]
- **字符串类型**: [定长vs变长选择]
- **时间类型**: [时区处理和精度选择]
- **JSON类型**: [半结构化数据存储]

**存储引擎选择**:
- **InnoDB**: [事务处理和行级锁定]
- **MyRocks**: [高压缩比和写优化]
- **ColumnStore**: [分析查询优化]

## 7. 性能优化设计

### 7.1 查询性能优化
**查询模式分析**:
- **热点查询**: [高频查询优化策略]
- **复杂查询**: [多表关联查询优化]
- **聚合查询**: [统计分析查询优化]
- **全文搜索**: [搜索查询优化策略]

**SQL优化策略**:
- **查询重写**: [等价查询变换]
- **子查询优化**: [EXISTS vs IN优化]
- **连接优化**: [JOIN顺序和算法选择]
- **分页优化**: [大偏移量分页优化]

### 7.2 缓存架构设计
**多级缓存策略**:
```
应用缓存(L1) ──┐
               ├── 缓存穿透保护
Redis缓存(L2) ──┤
               ├── 数据库保护
数据库(L3) ─────┘
```

**缓存策略**:
- **Cache-Aside**: [旁路缓存模式]
- **Write-Through**: [写透缓存模式]
- **Write-Behind**: [异步写回模式]
- **Refresh-Ahead**: [预刷新缓存]

**缓存一致性**:
- **强一致性**: [实时更新缓存]
- **最终一致性**: [延迟更新策略]
- **缓存失效**: [TTL和主动失效]

### 7.3 读写分离优化
**主从架构**:
- **主库职责**: [写操作和强一致性读]
- **从库职责**: [读操作和分析查询]
- **读写路由**: [应用层和中间件路由]
- **延迟处理**: [主从延迟的业务处理]

## 8. 数据安全设计

### 8.1 访问控制体系
**用户权限管理**:
- **数据库用户**: [应用用户和管理用户分离]
- **权限分级**: [读权限、写权限、管理权限]
- **最小权限**: [按需分配最小权限]
- **权限审计**: [权限使用情况监控]

**行级安全策略**:
- **RLS策略**: [基于用户的行级过滤]
- **多租户隔离**: [租户数据隔离]
- **数据脱敏**: [敏感数据展示脱敏]

### 8.2 数据加密策略
**传输加密**:
- **TLS连接**: [数据库连接加密]
- **证书管理**: [SSL证书配置和更新]

**存储加密**:
- **透明加密**: [TDE透明数据加密]
- **列级加密**: [敏感字段单独加密]
- **密钥管理**: [加密密钥轮换和保护]

### 8.3 审计和监控
**操作审计**:
- **DDL审计**: [结构变更记录]
- **DML审计**: [数据变更记录]
- **登录审计**: [用户访问记录]
- **权限审计**: [权限变更记录]

**安全监控**:
- **异常检测**: [SQL注入、暴力破解检测]
- **性能监控**: [慢查询、锁等待监控]
- **资源监控**: [连接数、存储使用监控]

## 9. 备份恢复体系

### 9.1 备份策略设计
**备份类型**:
- **全量备份**: [每周全量备份，离线存储]
- **增量备份**: [每日增量备份，快速恢复]
- **日志备份**: [事务日志连续备份]
- **快照备份**: [存储级快照，快速恢复]

**备份指标**:
- **RTO目标**: [恢复时间目标：≤30分钟]
- **RPO目标**: [恢复点目标：≤5分钟数据丢失]
- **备份窗口**: [备份对业务影响最小化]
- **存储成本**: [备份存储成本优化]

### 9.2 灾难恢复
**高可用架构**:
- **主从复制**: [异步/半同步复制]
- **故障转移**: [自动/手动切换]
- **数据中心**: [同城/异地灾备]
- **恢复演练**: [定期恢复测试]

## 10. 运维监控体系

### 10.1 性能监控
**关键指标监控**:
| 指标类别 | 具体指标 | 正常范围 | 告警阈值 | 监控工具 |
|----------|----------|----------|----------|----------|
| 查询性能 | 平均响应时间 | <100ms | >500ms | APM监控 |
| 吞吐量 | QPS | >1000 | <500 | 数据库监控 |
| 连接数 | 活跃连接 | <80% | >90% | 连接池监控 |
| 存储 | 磁盘使用率 | <70% | >85% | 系统监控 |

### 10.2 容量规划
**存储容量规划**:
- **当前容量**: [现有数据存储量]
- **增长预测**: [基于业务增长的容量预测]
- **扩容计划**: [容量扩展的时间点和方案]
- **成本分析**: [存储成本和性能的平衡]

### 10.3 数据库升级
**版本管理**:
- **升级策略**: [灰度升级、蓝绿部署]
- **兼容性测试**: [新版本兼容性验证]
- **回滚方案**: [升级失败的回滚预案]
- **数据迁移**: [升级过程的数据处理]

## 11. 实施路线图

### 11.1 分阶段实施
**第一阶段 (第1-2周)**: 基础环境搭建
- [ ] 数据库环境部署
- [ ] 基础表结构创建
- [ ] 连接和权限配置
- [ ] 基础监控部署

**第二阶段 (第3-4周)**: 核心功能实现
- [ ] 核心业务表创建
- [ ] 索引和约束配置
- [ ] 存储过程开发
- [ ] 数据初始化

**第三阶段 (第5-6周)**: 性能优化
- [ ] 查询性能调优
- [ ] 缓存策略实施
- [ ] 读写分离配置
- [ ] 性能压力测试

**第四阶段 (第7-8周)**: 安全和运维
- [ ] 安全策略实施
- [ ] 备份恢复测试
- [ ] 监控告警配置
- [ ] 运维流程建立

### 11.2 风险控制
**技术风险**:
- **性能风险**: [查询性能不达标的优化方案]
- **容量风险**: [数据增长超预期的扩容方案]
- **安全风险**: [数据泄露的防护和应急方案]

**实施风险**:
- **进度风险**: [实施延期的应对措施]
- **质量风险**: [数据质量问题的预防和处理]
- **团队风险**: [技能不足的培训和支持]

---
**文档版本**: v1.0
**设计时间**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**数据架构师**: 首席数据架构师 AI
**审核状态**: 待评审
**有效期**: 6个月 (建议定期更新)
"""

        # 执行专业数据库设计
        self.update_memory("user", design_prompt)
        result = await self.run()

        # 保存设计结果
        self._save_database_result(result)

        logger.info("✅ 专业数据库架构设计完成")
        return result

    def _save_database_result(self, database_result: str):
        """保存数据库设计结果到内存"""
        try:
            # 提取关键数据库决策
            database_type = self._extract_database_type(database_result)
            complexity_level = self._extract_data_complexity(database_result)

            self.database_summary = {
                "timestamp": datetime.now().isoformat(),
                "database_type": database_type,
                "complexity_level": complexity_level,
                "design_quality": "professional",
                "full_design": database_result,
            }

        except Exception as e:
            logger.warning(f"保存数据库设计结果时出错: {e}")

    def _extract_database_type(self, design: str) -> str:
        """从设计结果中提取数据库类型"""
        try:
            if "PostgreSQL" in design:
                return "PostgreSQL"
            elif "MySQL" in design:
                return "MySQL"
            elif "MongoDB" in design:
                return "MongoDB"
            elif "Oracle" in design:
                return "Oracle"
            else:
                return "混合数据库"
        except Exception:
            return "未识别"

    def _extract_data_complexity(self, design: str) -> str:
        """提取数据复杂度等级"""
        try:
            if "高复杂度" in design or "复杂" in design:
                return "高"
            elif "中复杂度" in design or "中等" in design:
                return "中"
            else:
                return "低"
        except Exception:
            return "未知"

    async def step(self) -> str:
        """执行单步数据库设计"""
        try:
            # 检查内存中是否有用户请求
            if not self.memory.messages:
                self.state = self.state.FINISHED
                return "没有数据库设计请求"

            # 获取最新的用户消息
            user_message = None
            for msg in reversed(self.memory.messages):
                if msg.role == "user":
                    user_message = msg
                    break

            if not user_message:
                self.state = self.state.FINISHED
                return "没有找到有效的用户请求"

            # 使用LLM进行分析
            messages = []
            if self.system_prompt:
                messages.append(Message.system_message(self.system_prompt))

            # 添加所有相关消息
            messages.extend(self.memory.messages)

            # 调用LLM
            result = await self.llm.ask(messages, stream=False)

            # 更新内存
            self.update_memory("assistant", result)

            # 标记完成
            self.state = self.state.FINISHED

            return result

        except Exception as e:
            logger.error(f"数据库设计失败: {e}")
            self.state = self.state.ERROR
            return f"设计失败: {str(e)}"

    def get_database_summary(self) -> Dict:
        """获取数据库设计摘要"""
        base_summary = {
            "designer": self.name,
            "status": self.state.value,
            "design_complete": self.state.value == "FINISHED",
            "design_type": "enterprise_data_architecture",
        }

        if hasattr(self, "database_summary"):
            base_summary.update(self.database_summary)

        return base_summary

    def get_database_technology_info(self, db_type: str) -> Optional[Dict]:
        """获取数据库技术信息"""
        for category, dbs in self.database_technologies.items():
            if db_type in dbs:
                return dbs[db_type]
        return None

    def get_modeling_practice(self, practice_type: str) -> Optional[Dict]:
        """获取数据建模最佳实践"""
        return self.modeling_practices.get(practice_type)

    def get_performance_optimization(self, optimization_type: str) -> Optional[Dict]:
        """获取性能优化策略"""
        return self.performance_optimization.get(optimization_type)

    async def analyze_query_performance(self, sql_queries: List[str]) -> Dict:
        """分析查询性能并提供优化建议"""
        logger.info("开始查询性能分析")

        analysis_prompt = f"""请对以下SQL查询进行性能分析和优化：

{chr(10).join(f'{i+1}. {query}' for i, query in enumerate(sql_queries))}

请从以下维度进行分析：
1. **执行计划分析**: 查询执行路径和成本分析
2. **索引建议**: 建议创建或优化的索引
3. **查询重写**: 等价但更高效的查询写法
4. **性能预估**: 预估查询性能和资源消耗
5. **监控建议**: 需要监控的性能指标

输出格式：
- 每个查询的详细分析
- 整体优化建议
- 性能监控建议
"""

        self.update_memory("user", analysis_prompt)
        result = await self.run()

        logger.info("查询性能分析完成")
        return {
            "analysis_result": result,
            "analysis_time": datetime.now().isoformat(),
            "analyzer": self.name,
        }
